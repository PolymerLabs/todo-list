<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../../bower_components/polymer/polymer.html">

<dom-module id="iron-sortable-list">
  <style>
    :host {
      display: block;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
    }
  </style>
  <template>
    <content></content>
  </template>
  <script>
    Polymer({
      is: 'iron-sortable-list',
      listeners: {
        scroll: 'handleScroll',
        'dom-change': 'trackElements'
      },
      handleScroll: function() {
        if (this.dragEl) {
          this.updateDragPosition();
        }
      },
      trackElements: function(e) {
        if (!this.repeater && e.target.is == 'dom-repeat') {
          this.repeater = e.target;
        }
        if (e.target == this.repeater) {
          Polymer.dom(this).children.forEach(function(el) {
            if (el !== this.repeater && !el.__reorderTracking) {
              this.listen(el, 'track', 'handleTrack');
              el.__reorderTracking = true;
            }
          }, this);
        }
      },
      handleTrack: function(e) {
        switch (e.detail.state) {
          case 'start':
            // Capture initial state
            this.startScrollTop = this.scrollTop;
            this.dragEl = e.target;
            this.dragEl.style.pointerEvents = 'none';
            this.dragEl.classList.add('dragging');
            this.dragModel = this.repeater.modelForElement(this.dragEl);
            break;
          case 'track':
            // Re-position dragged item
            this.updateDragPosition(e.detail.dy);
            // Translate non-dragged items up/down
            var overEl = e.detail.hover();
            var overModel = overEl && this.repeater.modelForElement(overEl);
            if (overModel) {
              this.overModel = overModel;
              this.dirOffset = e.detail.ddy < 0 ? -1 : 0;
              var lastOverIndex = this.overIndex || 0;
              var overIndex = overModel.index + this.dirOffset;
              var start = Math.max(overIndex < lastOverIndex ? overIndex : lastOverIndex, 0);
              var end = overModel.index < lastOverIndex ? lastOverIndex : overModel.index;
              var children = Polymer.dom(this).children;
              for (var i=start; i<=end; i++) {
                var el = children[i];
                if (el != this.repeater && i !== this.dragModel.index) {
                  var dir = 0;
                  if (i > this.dragModel.index && i <= overIndex) {
                    dir = -1;
                  } else if (i > overIndex && i < this.dragModel.index) {
                    dir = 1;
                  }
                  el.classList.add('moving');
                  this.translate3d(0, dir * this.dragEl.offsetHeight + 'px', 0, el);
                }
              }
              this.overIndex = overModel.index;
            }
            break;
          case 'end':
            // Move item in array to new position
            var fromIdx = this.repeater.items.indexOf(this.dragModel.item);
            if (fromIdx >= 0 && this.overModel) {
              var toIdx = this.repeater.items.indexOf(this.overModel.item) +
                (this.overModel.index > this.dragModel.index ? this.dirOffset : 0);
              var item = this.repeater.splice('items', fromIdx, 1)[0];
              this.repeater.splice('items', toIdx, 0, item);
            }
            // Reset style of dragged & moved elements
            this.dragEl.style.pointerEvents = '';
            this.dragEl.classList.remove('dragging');
            this.dragEl = null;
            Polymer.dom(this).children.forEach(function(el) {
              this.transform('', el);
              el.classList.remove('moving');
            }, this);
            break;
        }
      },
      updateDragPosition: function(dy) {
        this.trackDelta = dy || this.trackDelta || 0;
        var scrollDelta = this.scrollTop - this.startScrollTop;
        var pos = this.trackDelta + scrollDelta;
        this.translate3d(0, pos + 'px', 0, this.dragEl);
      }
    });
  </script>
</dom-module>
